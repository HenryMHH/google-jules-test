import { describe, it, expect } from 'vitest';
import { generateMaze, MAZE_WIDTH, MAZE_HEIGHT, Cell } from './mazeGenerator';

describe('generateMaze', () => {
  const testWidth = 10; // Use smaller dimensions for faster tests
  const testHeight = 10;
  let maze = generateMaze(testWidth, testHeight);

  // Re-generate maze for each test to ensure isolation if tests modify maze state (not the case here but good practice)
  // beforeEach(() => {
  //   maze = generateMaze(testWidth, testHeight);
  // });

  it('should return a maze of the specified dimensions', () => {
    expect(maze.length).toBe(testHeight);
    expect(maze[0].length).toBe(testWidth);
  });

  it('should have exactly one start cell', () => {
    let startCellCount = 0;
    for (let y = 0; y < testHeight; y++) {
      for (let x = 0; x < testWidth; x++) {
        if (maze[y][x].isStart) {
          startCellCount++;
        }
      }
    }
    expect(startCellCount).toBe(1);
  });

  it('should have exactly one end cell', () => {
    let endCellCount = 0;
    for (let y = 0; y < testHeight; y++) {
      for (let x = 0; x < testWidth; x++) {
        if (maze[y][x].isEnd) {
          endCellCount++;
        }
      }
    }
    expect(endCellCount).toBe(1);
  });

  it('should have the start cell at the top border (0,1) and be a path', () => {
    const startCell = maze[0][1];
    expect(startCell.isStart).toBe(true);
    expect(startCell.isWall).toBe(false);
    // Check that the cell connecting to the inner maze is also a path
    if (testHeight > 1) { // Avoid error for 1xN mazes
        expect(maze[1][1].isWall).toBe(false);
    }
  });

  it('should have the end cell at the bottom border (H-1, W-2) and be a path', () => {
    const endCell = maze[testHeight - 1][testWidth - 2];
    expect(endCell.isEnd).toBe(true);
    expect(endCell.isWall).toBe(false);
    // Check that the cell connecting to the inner maze is also a path
     if (testHeight > 2 && testWidth > 2) { // Avoid error for small mazes
        expect(maze[testHeight - 2][testWidth - 2].isWall).toBe(false);
    }
  });

  it('should have at least one path cell that is not a wall (besides start/end)', () => {
    let pathCellCount = 0;
    for (let y = 0; y < testHeight; y++) {
      for (let x = 0; x < testWidth; x++) {
        if (!maze[y][x].isWall) {
          pathCellCount++;
        }
      }
    }
    // Expect more than just start and end to be paths in a typical maze
    expect(pathCellCount).toBeGreaterThan(2); 
  });

  it('should have a reasonable percentage of path cells', () => {
    let pathCellCount = 0;
    for (let y = 0; y < testHeight; y++) {
      for (let x = 0; x < testWidth; x++) {
        if (!maze[y][x].isWall) {
          pathCellCount++;
        }
      }
    }
    const totalCells = testWidth * testHeight;
    const pathPercentage = (pathCellCount / totalCells) * 100;
    // For a typical maze generated by DFS, expect a good portion to be paths.
    // This is a heuristic. For a 10x10 maze, 20-50% paths seems reasonable.
    // If it's too low, the maze might be overly dense with walls or generation failed.
    expect(pathPercentage).toBeGreaterThanOrEqual(15); // Adjusted for smaller test maze
    expect(pathPercentage).toBeLessThanOrEqual(70); // Max reasonable path percentage
  });

  it('should ensure start and end cells are correctly identified and are not walls', () => {
    let startCell: Cell | null = null;
    let endCell: Cell | null = null;

    for (let y = 0; y < testHeight; y++) {
      for (let x = 0; x < testWidth; x++) {
        if (maze[y][x].isStart) startCell = maze[y][x];
        if (maze[y][x].isEnd) endCell = maze[y][x];
      }
    }

    expect(startCell).not.toBeNull();
    expect(endCell).not.toBeNull();
    if (startCell) expect(startCell.isWall).toBe(false);
    if (endCell) expect(endCell.isWall).toBe(false);
  });
});
